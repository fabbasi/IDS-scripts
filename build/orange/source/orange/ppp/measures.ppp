 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../measures.hpp"
#include <cstddef>



/****** TMeasureAttribute *****/

void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_properties[] = {
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_components[] = { 0};
TClassDescription TMeasureAttribute::st_classDescription = { "TMeasureAttribute", &typeid(TMeasureAttribute), &TOrange::st_classDescription, TMeasureAttribute_properties, TMeasureAttribute_components };
TClassDescription const *TMeasureAttribute::classDescription() const { return &TMeasureAttribute::st_classDescription; }
TOrange *TMeasureAttribute::clone() const { return mlnew TMeasureAttribute(*this); }


/****** TMeasureAttributeFromProbabilities *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttributeFromProbabilities_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttributeFromProbabilities, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttributeFromProbabilities, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttributeFromProbabilities, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttributeFromProbabilities, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttributeFromProbabilities, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttributeFromProbabilities, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttributeFromProbabilities, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttributeFromProbabilities_components[] = { offsetof(TMeasureAttributeFromProbabilities, estimatorConstructor), offsetof(TMeasureAttributeFromProbabilities, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttributeFromProbabilities::st_classDescription = { "TMeasureAttributeFromProbabilities", &typeid(TMeasureAttributeFromProbabilities), &TMeasureAttribute::st_classDescription, TMeasureAttributeFromProbabilities_properties, TMeasureAttributeFromProbabilities_components };
TClassDescription const *TMeasureAttributeFromProbabilities::classDescription() const { return &TMeasureAttributeFromProbabilities::st_classDescription; }


/****** TMeasureAttribute_info *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_info_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_info, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_info, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_info, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_info, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_info, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_info, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_info, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_info_components[] = { offsetof(TMeasureAttribute_info, estimatorConstructor), offsetof(TMeasureAttribute_info, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_info::st_classDescription = { "TMeasureAttribute_info", &typeid(TMeasureAttribute_info), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_info_properties, TMeasureAttribute_info_components };
TClassDescription const *TMeasureAttribute_info::classDescription() const { return &TMeasureAttribute_info::st_classDescription; }
TOrange *TMeasureAttribute_info::clone() const { return mlnew TMeasureAttribute_info(*this); }


/****** TMeasureAttribute_gainRatio *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_gainRatio_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gainRatio, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gainRatio, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_gainRatio, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_gainRatio, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatio, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatio, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatio, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_gainRatio_components[] = { offsetof(TMeasureAttribute_gainRatio, estimatorConstructor), offsetof(TMeasureAttribute_gainRatio, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_gainRatio::st_classDescription = { "TMeasureAttribute_gainRatio", &typeid(TMeasureAttribute_gainRatio), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_gainRatio_properties, TMeasureAttribute_gainRatio_components };
TClassDescription const *TMeasureAttribute_gainRatio::classDescription() const { return &TMeasureAttribute_gainRatio::st_classDescription; }
TOrange *TMeasureAttribute_gainRatio::clone() const { return mlnew TMeasureAttribute_gainRatio(*this); }


/****** TMeasureAttribute_gainRatioA *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_gainRatioA_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gainRatioA, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gainRatioA, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_gainRatioA, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_gainRatioA, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatioA, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatioA, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gainRatioA, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_gainRatioA_components[] = { offsetof(TMeasureAttribute_gainRatioA, estimatorConstructor), offsetof(TMeasureAttribute_gainRatioA, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_gainRatioA::st_classDescription = { "TMeasureAttribute_gainRatioA", &typeid(TMeasureAttribute_gainRatioA), &TMeasureAttribute_gainRatio::st_classDescription, TMeasureAttribute_gainRatioA_properties, TMeasureAttribute_gainRatioA_components };
TClassDescription const *TMeasureAttribute_gainRatioA::classDescription() const { return &TMeasureAttribute_gainRatioA::st_classDescription; }
TOrange *TMeasureAttribute_gainRatioA::clone() const { return mlnew TMeasureAttribute_gainRatioA(*this); }


/****** TMeasureAttribute_gini *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_gini_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gini, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_gini, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_gini, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_gini, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gini, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gini, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_gini, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_gini_components[] = { offsetof(TMeasureAttribute_gini, estimatorConstructor), offsetof(TMeasureAttribute_gini, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_gini::st_classDescription = { "TMeasureAttribute_gini", &typeid(TMeasureAttribute_gini), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_gini_properties, TMeasureAttribute_gini_components };
TClassDescription const *TMeasureAttribute_gini::classDescription() const { return &TMeasureAttribute_gini::st_classDescription; }
TOrange *TMeasureAttribute_gini::clone() const { return mlnew TMeasureAttribute_gini(*this); }


/****** TMeasureAttribute_logOddsRatio *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_logOddsRatio_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_logOddsRatio, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_logOddsRatio, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_logOddsRatio, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_logOddsRatio, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_logOddsRatio, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_logOddsRatio, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_logOddsRatio, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_logOddsRatio_components[] = { offsetof(TMeasureAttribute_logOddsRatio, estimatorConstructor), offsetof(TMeasureAttribute_logOddsRatio, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_logOddsRatio::st_classDescription = { "TMeasureAttribute_logOddsRatio", &typeid(TMeasureAttribute_logOddsRatio), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_logOddsRatio_properties, TMeasureAttribute_logOddsRatio_components };
TClassDescription const *TMeasureAttribute_logOddsRatio::classDescription() const { return &TMeasureAttribute_logOddsRatio::st_classDescription; }
TOrange *TMeasureAttribute_logOddsRatio::clone() const { return mlnew TMeasureAttribute_logOddsRatio(*this); }


/****** TMeasureAttribute_relevance *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_relevance_properties[] = {
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_relevance, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_relevance, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_relevance, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_relevance, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_relevance, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_relevance, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_relevance, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_relevance_components[] = { offsetof(TMeasureAttribute_relevance, estimatorConstructor), offsetof(TMeasureAttribute_relevance, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_relevance::st_classDescription = { "TMeasureAttribute_relevance", &typeid(TMeasureAttribute_relevance), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_relevance_properties, TMeasureAttribute_relevance_components };
TClassDescription const *TMeasureAttribute_relevance::classDescription() const { return &TMeasureAttribute_relevance::st_classDescription; }
TOrange *TMeasureAttribute_relevance::clone() const { return mlnew TMeasureAttribute_relevance(*this); }


/****** TMeasureAttribute_chiSquare *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_chiSquare_properties[] = {
  {"compute_probabilities", "", &typeid(bool), NULL, offsetof(TMeasureAttribute_chiSquare, computeProbabilities), false, false, 0},
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_chiSquare, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_chiSquare, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_chiSquare, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_chiSquare, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_chiSquare, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_chiSquare, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_chiSquare, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_chiSquare_components[] = { offsetof(TMeasureAttribute_chiSquare, estimatorConstructor), offsetof(TMeasureAttribute_chiSquare, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_chiSquare::st_classDescription = { "TMeasureAttribute_chiSquare", &typeid(TMeasureAttribute_chiSquare), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_chiSquare_properties, TMeasureAttribute_chiSquare_components };
TClassDescription const *TMeasureAttribute_chiSquare::classDescription() const { return &TMeasureAttribute_chiSquare::st_classDescription; }
TOrange *TMeasureAttribute_chiSquare::clone() const { return mlnew TMeasureAttribute_chiSquare(*this); }


/****** TMeasureAttribute_cost *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_cost_properties[] = {
  {"cost", "cost matrix", &typeid(POrange), &TCostMatrix::st_classDescription, offsetof(TMeasureAttribute_cost, cost), false, false, 0},
  {"estimator_constructor", "probability estimator (none by default)", &typeid(POrange), &TProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_cost, estimatorConstructor), false, false, 0},
  {"conditional_estimator_constructor", "conditional probability estimator (none by default)", &typeid(POrange), &TConditionalProbabilityEstimatorConstructor::st_classDescription, offsetof(TMeasureAttribute_cost, conditionalEstimatorConstructor), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_cost, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_cost, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_cost, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_cost, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_cost, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_cost_components[] = { offsetof(TMeasureAttribute_cost, cost), offsetof(TMeasureAttribute_cost, estimatorConstructor), offsetof(TMeasureAttribute_cost, conditionalEstimatorConstructor), 0};
TClassDescription TMeasureAttribute_cost::st_classDescription = { "TMeasureAttribute_cost", &typeid(TMeasureAttribute_cost), &TMeasureAttributeFromProbabilities::st_classDescription, TMeasureAttribute_cost_properties, TMeasureAttribute_cost_components };
TClassDescription const *TMeasureAttribute_cost::classDescription() const { return &TMeasureAttribute_cost::st_classDescription; }
TOrange *TMeasureAttribute_cost::clone() const { return mlnew TMeasureAttribute_cost(*this); }


/****** TMeasureAttribute_MSE *****/

void *PTMeasureAttribute_UnknownsTreatment(void *);
void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_MSE_properties[] = {
  {"m", "m for m-estimate", &typeid(float), NULL, offsetof(TMeasureAttribute_MSE, m), false, false, 0},
  {"unknowns_treatment", " treatment of unknown values", &typeid(int), NULL, offsetof(TMeasureAttribute_MSE, unknownsTreatment), false, false, PTMeasureAttribute_UnknownsTreatment},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_MSE, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_MSE, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_MSE, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_MSE, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_MSE_components[] = { 0};
TClassDescription TMeasureAttribute_MSE::st_classDescription = { "TMeasureAttribute_MSE", &typeid(TMeasureAttribute_MSE), &TMeasureAttribute::st_classDescription, TMeasureAttribute_MSE_properties, TMeasureAttribute_MSE_components };
TClassDescription const *TMeasureAttribute_MSE::classDescription() const { return &TMeasureAttribute_MSE::st_classDescription; }
TOrange *TMeasureAttribute_MSE::clone() const { return mlnew TMeasureAttribute_MSE(*this); }
