 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../minimal_error.hpp"
#include <cstddef>



/****** TColumnAssessor *****/


TPropertyDescription TColumnAssessor_properties[] = {
  {NULL}
};

size_t const TColumnAssessor_components[] = { 0};
TClassDescription TColumnAssessor::st_classDescription = { "TColumnAssessor", &typeid(TColumnAssessor), &TOrange::st_classDescription, TColumnAssessor_properties, TColumnAssessor_components };
TClassDescription const *TColumnAssessor::classDescription() const { return &TColumnAssessor::st_classDescription; }


/****** TColumnAssessor_m *****/


TPropertyDescription TColumnAssessor_m_properties[] = {
  {"m", "m for m-estimate", &typeid(float), NULL, offsetof(TColumnAssessor_m, m), false, false, 0},
  {NULL}
};

size_t const TColumnAssessor_m_components[] = { 0};
TClassDescription TColumnAssessor_m::st_classDescription = { "TColumnAssessor_m", &typeid(TColumnAssessor_m), &TColumnAssessor::st_classDescription, TColumnAssessor_m_properties, TColumnAssessor_m_components };
TClassDescription const *TColumnAssessor_m::classDescription() const { return &TColumnAssessor_m::st_classDescription; }
TOrange *TColumnAssessor_m::clone() const { return mlnew TColumnAssessor_m(*this); }


/****** TColumnAssessor_Laplace *****/


TPropertyDescription TColumnAssessor_Laplace_properties[] = {
  {NULL}
};

size_t const TColumnAssessor_Laplace_components[] = { 0};
TClassDescription TColumnAssessor_Laplace::st_classDescription = { "TColumnAssessor_Laplace", &typeid(TColumnAssessor_Laplace), &TColumnAssessor::st_classDescription, TColumnAssessor_Laplace_properties, TColumnAssessor_Laplace_components };
TClassDescription const *TColumnAssessor_Laplace::classDescription() const { return &TColumnAssessor_Laplace::st_classDescription; }
TOrange *TColumnAssessor_Laplace::clone() const { return mlnew TColumnAssessor_Laplace(*this); }


/****** TColumnAssessor_N *****/


TPropertyDescription TColumnAssessor_N_properties[] = {
  {NULL}
};

size_t const TColumnAssessor_N_components[] = { 0};
TClassDescription TColumnAssessor_N::st_classDescription = { "TColumnAssessor_N", &typeid(TColumnAssessor_N), &TColumnAssessor::st_classDescription, TColumnAssessor_N_properties, TColumnAssessor_N_components };
TClassDescription const *TColumnAssessor_N::classDescription() const { return &TColumnAssessor_N::st_classDescription; }
TOrange *TColumnAssessor_N::clone() const { return mlnew TColumnAssessor_N(*this); }


/****** TColumnAssessor_Relief *****/


TPropertyDescription TColumnAssessor_Relief_properties[] = {
  {NULL}
};

size_t const TColumnAssessor_Relief_components[] = { 0};
TClassDescription TColumnAssessor_Relief::st_classDescription = { "TColumnAssessor_Relief", &typeid(TColumnAssessor_Relief), &TColumnAssessor::st_classDescription, TColumnAssessor_Relief_properties, TColumnAssessor_Relief_components };
TClassDescription const *TColumnAssessor_Relief::classDescription() const { return &TColumnAssessor_Relief::st_classDescription; }
TOrange *TColumnAssessor_Relief::clone() const { return mlnew TColumnAssessor_Relief(*this); }


/****** TColumnAssessor_Kramer *****/


TPropertyDescription TColumnAssessor_Kramer_properties[] = {
  {NULL}
};

size_t const TColumnAssessor_Kramer_components[] = { 0};
TClassDescription TColumnAssessor_Kramer::st_classDescription = { "TColumnAssessor_Kramer", &typeid(TColumnAssessor_Kramer), &TColumnAssessor::st_classDescription, TColumnAssessor_Kramer_properties, TColumnAssessor_Kramer_components };
TClassDescription const *TColumnAssessor_Kramer::classDescription() const { return &TColumnAssessor_Kramer::st_classDescription; }
TOrange *TColumnAssessor_Kramer::clone() const { return mlnew TColumnAssessor_Kramer(*this); }


/****** TColumnAssessor_Measure *****/


TPropertyDescription TColumnAssessor_Measure_properties[] = {
  {"measure", "attribute quality measure", &typeid(POrange), &TMeasureAttribute::st_classDescription, offsetof(TColumnAssessor_Measure, measure), false, false, 0},
  {NULL}
};

size_t const TColumnAssessor_Measure_components[] = { offsetof(TColumnAssessor_Measure, measure), 0};
TClassDescription TColumnAssessor_Measure::st_classDescription = { "TColumnAssessor_Measure", &typeid(TColumnAssessor_Measure), &TColumnAssessor::st_classDescription, TColumnAssessor_Measure_properties, TColumnAssessor_Measure_components };
TClassDescription const *TColumnAssessor_Measure::classDescription() const { return &TColumnAssessor_Measure::st_classDescription; }
TOrange *TColumnAssessor_Measure::clone() const { return mlnew TColumnAssessor_Measure(*this); }


/****** TColumnAssessor_mf *****/


TPropertyDescription TColumnAssessor_mf_properties[] = {
  {"m", "m for m-estimate", &typeid(float), NULL, offsetof(TColumnAssessor_mf, m), false, false, 0},
  {NULL}
};

size_t const TColumnAssessor_mf_components[] = { 0};
TClassDescription TColumnAssessor_mf::st_classDescription = { "TColumnAssessor_mf", &typeid(TColumnAssessor_mf), &TColumnAssessor::st_classDescription, TColumnAssessor_mf_properties, TColumnAssessor_mf_components };
TClassDescription const *TColumnAssessor_mf::classDescription() const { return &TColumnAssessor_mf::st_classDescription; }
TOrange *TColumnAssessor_mf::clone() const { return mlnew TColumnAssessor_mf(*this); }


/****** TStopIMClusteringByAssessor *****/


TPropertyDescription TStopIMClusteringByAssessor_properties[] = {
  {NULL}
};

size_t const TStopIMClusteringByAssessor_components[] = { 0};
TClassDescription TStopIMClusteringByAssessor::st_classDescription = { "TStopIMClusteringByAssessor", &typeid(TStopIMClusteringByAssessor), &TOrange::st_classDescription, TStopIMClusteringByAssessor_properties, TStopIMClusteringByAssessor_components };
TClassDescription const *TStopIMClusteringByAssessor::classDescription() const { return &TStopIMClusteringByAssessor::st_classDescription; }


/****** TStopIMClusteringByAssessor_noProfit *****/


TPropertyDescription TStopIMClusteringByAssessor_noProfit_properties[] = {
  {"min_profit_proportion", "minimal allowable profit proportion", &typeid(float), NULL, offsetof(TStopIMClusteringByAssessor_noProfit, minProfitProportion), false, false, 0},
  {NULL}
};

size_t const TStopIMClusteringByAssessor_noProfit_components[] = { 0};
TClassDescription TStopIMClusteringByAssessor_noProfit::st_classDescription = { "TStopIMClusteringByAssessor_noProfit", &typeid(TStopIMClusteringByAssessor_noProfit), &TStopIMClusteringByAssessor::st_classDescription, TStopIMClusteringByAssessor_noProfit_properties, TStopIMClusteringByAssessor_noProfit_components };
TClassDescription const *TStopIMClusteringByAssessor_noProfit::classDescription() const { return &TStopIMClusteringByAssessor_noProfit::st_classDescription; }
TOrange *TStopIMClusteringByAssessor_noProfit::clone() const { return mlnew TStopIMClusteringByAssessor_noProfit(*this); }


/****** TStopIMClusteringByAssessor_noBigChange *****/


TPropertyDescription TStopIMClusteringByAssessor_noBigChange_properties[] = {
  {NULL}
};

size_t const TStopIMClusteringByAssessor_noBigChange_components[] = { 0};
TClassDescription TStopIMClusteringByAssessor_noBigChange::st_classDescription = { "TStopIMClusteringByAssessor_noBigChange", &typeid(TStopIMClusteringByAssessor_noBigChange), &TStopIMClusteringByAssessor::st_classDescription, TStopIMClusteringByAssessor_noBigChange_properties, TStopIMClusteringByAssessor_noBigChange_components };
TClassDescription const *TStopIMClusteringByAssessor_noBigChange::classDescription() const { return &TStopIMClusteringByAssessor_noBigChange::st_classDescription; }
TOrange *TStopIMClusteringByAssessor_noBigChange::clone() const { return mlnew TStopIMClusteringByAssessor_noBigChange(*this); }


/****** TStopIMClusteringByAssessor_binary *****/


TPropertyDescription TStopIMClusteringByAssessor_binary_properties[] = {
  {NULL}
};

size_t const TStopIMClusteringByAssessor_binary_components[] = { 0};
TClassDescription TStopIMClusteringByAssessor_binary::st_classDescription = { "TStopIMClusteringByAssessor_binary", &typeid(TStopIMClusteringByAssessor_binary), &TStopIMClusteringByAssessor::st_classDescription, TStopIMClusteringByAssessor_binary_properties, TStopIMClusteringByAssessor_binary_components };
TClassDescription const *TStopIMClusteringByAssessor_binary::classDescription() const { return &TStopIMClusteringByAssessor_binary::st_classDescription; }
TOrange *TStopIMClusteringByAssessor_binary::clone() const { return mlnew TStopIMClusteringByAssessor_binary(*this); }


/****** TStopIMClusteringByAssessor_n *****/


TPropertyDescription TStopIMClusteringByAssessor_n_properties[] = {
  {"n", "number of clusters", &typeid(int), NULL, offsetof(TStopIMClusteringByAssessor_n, n), false, false, 0},
  {NULL}
};

size_t const TStopIMClusteringByAssessor_n_components[] = { 0};
TClassDescription TStopIMClusteringByAssessor_n::st_classDescription = { "TStopIMClusteringByAssessor_n", &typeid(TStopIMClusteringByAssessor_n), &TStopIMClusteringByAssessor::st_classDescription, TStopIMClusteringByAssessor_n_properties, TStopIMClusteringByAssessor_n_components };
TClassDescription const *TStopIMClusteringByAssessor_n::classDescription() const { return &TStopIMClusteringByAssessor_n::st_classDescription; }
TOrange *TStopIMClusteringByAssessor_n::clone() const { return mlnew TStopIMClusteringByAssessor_n(*this); }


/****** TAssessIMQuality *****/


TPropertyDescription TAssessIMQuality_properties[] = {
  {"column_assessor", "column quality assessor", &typeid(POrange), &TColumnAssessor::st_classDescription, offsetof(TAssessIMQuality, columnAssessor), false, false, 0},
  {NULL}
};

size_t const TAssessIMQuality_components[] = { offsetof(TAssessIMQuality, columnAssessor), 0};
TClassDescription TAssessIMQuality::st_classDescription = { "TAssessIMQuality", &typeid(TAssessIMQuality), &TOrange::st_classDescription, TAssessIMQuality_properties, TAssessIMQuality_components };
TClassDescription const *TAssessIMQuality::classDescription() const { return &TAssessIMQuality::st_classDescription; }
TOrange *TAssessIMQuality::clone() const { return mlnew TAssessIMQuality(*this); }


/****** TIMClustering *****/


TPropertyDescription TIMClustering_properties[] = {
  {"im", "incompatibilty matrix", &typeid(POrange), &TIM::st_classDescription, offsetof(TIMClustering, im), false, false, 0},
  {"clusters", "cluster index for each matrix column", &typeid(POrange), &TIntList::st_classDescription, offsetof(TIMClustering, clusters), false, false, 0},
  {"max_cluster", "the highest cluster index", &typeid(int), NULL, offsetof(TIMClustering, maxCluster), false, false, 0},
  {"quality", "cluster quality", &typeid(float), NULL, offsetof(TIMClustering, quality), false, false, 0},
  {NULL}
};

size_t const TIMClustering_components[] = { offsetof(TIMClustering, im), offsetof(TIMClustering, clusters), 0};
TClassDescription TIMClustering::st_classDescription = { "TIMClustering", &typeid(TIMClustering), &TOrange::st_classDescription, TIMClustering_properties, TIMClustering_components };
TClassDescription const *TIMClustering::classDescription() const { return &TIMClustering::st_classDescription; }
TOrange *TIMClustering::clone() const { return mlnew TIMClustering(*this); }


/****** TClustersFromIM *****/


TPropertyDescription TClustersFromIM_properties[] = {
  {NULL}
};

size_t const TClustersFromIM_components[] = { 0};
TClassDescription TClustersFromIM::st_classDescription = { "TClustersFromIM", &typeid(TClustersFromIM), &TOrange::st_classDescription, TClustersFromIM_properties, TClustersFromIM_components };
TClassDescription const *TClustersFromIM::classDescription() const { return &TClustersFromIM::st_classDescription; }


/****** TClustersFromIMByAssessor *****/


TPropertyDescription TClustersFromIMByAssessor_properties[] = {
  {"column_assessor", "column quality assessor", &typeid(POrange), &TColumnAssessor::st_classDescription, offsetof(TClustersFromIMByAssessor, columnAssessor), false, false, 0},
  {"stop_criterion", "stop criterion", &typeid(POrange), &TStopIMClusteringByAssessor::st_classDescription, offsetof(TClustersFromIMByAssessor, stopCriterion), false, false, 0},
  {NULL}
};

size_t const TClustersFromIMByAssessor_components[] = { offsetof(TClustersFromIMByAssessor, columnAssessor), offsetof(TClustersFromIMByAssessor, stopCriterion), 0};
TClassDescription TClustersFromIMByAssessor::st_classDescription = { "TClustersFromIMByAssessor", &typeid(TClustersFromIMByAssessor), &TClustersFromIM::st_classDescription, TClustersFromIMByAssessor_properties, TClustersFromIMByAssessor_components };
TClassDescription const *TClustersFromIMByAssessor::classDescription() const { return &TClustersFromIMByAssessor::st_classDescription; }
TOrange *TClustersFromIMByAssessor::clone() const { return mlnew TClustersFromIMByAssessor(*this); }


/****** TFeatureByIM *****/

void *PTFeatureByIM_Completion(void *);

TPropertyDescription TFeatureByIM_properties[] = {
  {"IMconstructor", "incompatibility matrix constructor", &typeid(POrange), &TIMConstructor::st_classDescription, offsetof(TFeatureByIM, IMconstructor), false, false, 0},
  {"clusters_from_IM", "clustering algorithm", &typeid(POrange), &TClustersFromIM::st_classDescription, offsetof(TFeatureByIM, clustersFromIM), false, false, 0},
  {"completion", " decides how to determine the class for points not covered by any cluster", &typeid(int), NULL, offsetof(TFeatureByIM, completion), false, false, PTFeatureByIM_Completion},
  {NULL}
};

size_t const TFeatureByIM_components[] = { offsetof(TFeatureByIM, IMconstructor), offsetof(TFeatureByIM, clustersFromIM), 0};
TClassDescription TFeatureByIM::st_classDescription = { "TFeatureByIM", &typeid(TFeatureByIM), &TFeatureInducer::st_classDescription, TFeatureByIM_properties, TFeatureByIM_components };
TClassDescription const *TFeatureByIM::classDescription() const { return &TFeatureByIM::st_classDescription; }
TOrange *TFeatureByIM::clone() const { return mlnew TFeatureByIM(*this); }


/****** TMeasureAttribute_IM *****/

void *PTMeasureAttribute_Needs(void *);

TPropertyDescription TMeasureAttribute_IM_properties[] = {
  {"IMconstructor", "incompatibility matrix constructor", &typeid(POrange), &TIMConstructor::st_classDescription, offsetof(TMeasureAttribute_IM, IMconstructor), false, false, 0},
  {"column_assessor", "column quality assessor", &typeid(POrange), &TColumnAssessor::st_classDescription, offsetof(TMeasureAttribute_IM, columnAssessor), false, false, 0},
  {"needs", " describes what kind of data is needed for computation", &typeid(int), NULL, offsetof(TMeasureAttribute_IM, needs), false, false, PTMeasureAttribute_Needs},
  {"handles_discrete", "tells whether the measure can handle discrete attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_IM, handlesDiscrete), false, false, 0},
  {"handles_continuous", "tells whether the measure can handle continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_IM, handlesContinuous), false, false, 0},
  {"computes_thresholds", "tells whether the measure can compute threshold functions/maxima for continuous attributes", &typeid(bool), NULL, offsetof(TMeasureAttribute_IM, computesThresholds), false, false, 0},
  {NULL}
};

size_t const TMeasureAttribute_IM_components[] = { offsetof(TMeasureAttribute_IM, IMconstructor), offsetof(TMeasureAttribute_IM, columnAssessor), 0};
TClassDescription TMeasureAttribute_IM::st_classDescription = { "TMeasureAttribute_IM", &typeid(TMeasureAttribute_IM), &TMeasureAttribute::st_classDescription, TMeasureAttribute_IM_properties, TMeasureAttribute_IM_components };
TClassDescription const *TMeasureAttribute_IM::classDescription() const { return &TMeasureAttribute_IM::st_classDescription; }
TOrange *TMeasureAttribute_IM::clone() const { return mlnew TMeasureAttribute_IM(*this); }
