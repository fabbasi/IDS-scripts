 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../vars.hpp"
#include <cstddef>



/****** TVariable *****/

void *PTVariable_Type(void *);

TPropertyDescription TVariable_properties[] = {
  {"var_type", " variable type", &typeid(int), NULL, offsetof(TVariable, varType), false, false, PTVariable_Type},
  {"ordered", "variable values are ordered", &typeid(bool), NULL, offsetof(TVariable, ordered), false, false, 0},
  {"distributed", "variable values are distributions", &typeid(bool), NULL, offsetof(TVariable, distributed), false, false, 0},
  {"default_meta_id", "default (proposed, suggested...) meta id for this variable", &typeid(int), NULL, offsetof(TVariable, defaultMetaId), false, false, 0},
  {"random_generator", "random generator for random values (initialized when first needed)", &typeid(POrange), &TRandomGenerator::st_classDescription, offsetof(TVariable, randomGenerator), false, false, 0},
  {"source_variable", "The attribute that this attribute is computed from (when applicable)", &typeid(POrange), &TVariable::st_classDescription, offsetof(TVariable, sourceVariable), false, false, 0},
  {"get_value_from", "Function to compute the value from values of other variables", &typeid(POrange), &TClassifier::st_classDescription, offsetof(TVariable, getValueFrom), false, false, 0},
  {NULL}
};

size_t const TVariable_components[] = { offsetof(TVariable, randomGenerator), offsetof(TVariable, sourceVariable), offsetof(TVariable, getValueFrom), 0};
TClassDescription TVariable::st_classDescription = { "TVariable", &typeid(TVariable), &TOrange::st_classDescription, TVariable_properties, TVariable_components };
TClassDescription const *TVariable::classDescription() const { return &TVariable::st_classDescription; }


/****** TEnumVariable *****/

void *PTVariable_Type(void *);

TPropertyDescription TEnumVariable_properties[] = {
  {"values", "attribute's values", &typeid(POrange), &TStringList::st_classDescription, offsetof(TEnumVariable, values), false, false, 0},
  {"base_value", "the index of the base value", &typeid(int), NULL, offsetof(TEnumVariable, baseValue), false, false, 0},
  {"var_type", " variable type", &typeid(int), NULL, offsetof(TEnumVariable, varType), false, false, PTVariable_Type},
  {"ordered", "variable values are ordered", &typeid(bool), NULL, offsetof(TEnumVariable, ordered), false, false, 0},
  {"distributed", "variable values are distributions", &typeid(bool), NULL, offsetof(TEnumVariable, distributed), false, false, 0},
  {"default_meta_id", "default (proposed, suggested...) meta id for this variable", &typeid(int), NULL, offsetof(TEnumVariable, defaultMetaId), false, false, 0},
  {"random_generator", "random generator for random values (initialized when first needed)", &typeid(POrange), &TRandomGenerator::st_classDescription, offsetof(TEnumVariable, randomGenerator), false, false, 0},
  {"source_variable", "The attribute that this attribute is computed from (when applicable)", &typeid(POrange), &TVariable::st_classDescription, offsetof(TEnumVariable, sourceVariable), false, false, 0},
  {"get_value_from", "Function to compute the value from values of other variables", &typeid(POrange), &TClassifier::st_classDescription, offsetof(TEnumVariable, getValueFrom), false, false, 0},
  {NULL}
};

size_t const TEnumVariable_components[] = { offsetof(TEnumVariable, values), offsetof(TEnumVariable, randomGenerator), offsetof(TEnumVariable, sourceVariable), offsetof(TEnumVariable, getValueFrom), 0};
TClassDescription TEnumVariable::st_classDescription = { "TEnumVariable", &typeid(TEnumVariable), &TVariable::st_classDescription, TEnumVariable_properties, TEnumVariable_components };
TClassDescription const *TEnumVariable::classDescription() const { return &TEnumVariable::st_classDescription; }
TOrange *TEnumVariable::clone() const { return mlnew TEnumVariable(*this); }


/****** TFloatVariable *****/

void *PTVariable_Type(void *);

TPropertyDescription TFloatVariable_properties[] = {
  {"start_value", "lowest value", &typeid(float), NULL, offsetof(TFloatVariable, startValue), false, false, 0},
  {"end_value", "highest value", &typeid(float), NULL, offsetof(TFloatVariable, endValue), false, false, 0},
  {"step_value", "step", &typeid(float), NULL, offsetof(TFloatVariable, stepValue), false, false, 0},
  {"number_of_decimals", "number of digits after decimal point", &typeid(int), NULL, offsetof(TFloatVariable, numberOfDecimals), false, false, 0},
  {"scientific_format", "use scientific format in output", &typeid(bool), NULL, offsetof(TFloatVariable, scientificFormat), false, false, 0},
  {"adjust_decimals", "adjust number of decimals according to the values converted (0 - no, 1 - yes, 2 - yes, but haven't seen any yet)", &typeid(int), NULL, offsetof(TFloatVariable, adjustDecimals), false, false, 0},
  {"var_type", " variable type", &typeid(int), NULL, offsetof(TFloatVariable, varType), false, false, PTVariable_Type},
  {"ordered", "variable values are ordered", &typeid(bool), NULL, offsetof(TFloatVariable, ordered), false, false, 0},
  {"distributed", "variable values are distributions", &typeid(bool), NULL, offsetof(TFloatVariable, distributed), false, false, 0},
  {"default_meta_id", "default (proposed, suggested...) meta id for this variable", &typeid(int), NULL, offsetof(TFloatVariable, defaultMetaId), false, false, 0},
  {"random_generator", "random generator for random values (initialized when first needed)", &typeid(POrange), &TRandomGenerator::st_classDescription, offsetof(TFloatVariable, randomGenerator), false, false, 0},
  {"source_variable", "The attribute that this attribute is computed from (when applicable)", &typeid(POrange), &TVariable::st_classDescription, offsetof(TFloatVariable, sourceVariable), false, false, 0},
  {"get_value_from", "Function to compute the value from values of other variables", &typeid(POrange), &TClassifier::st_classDescription, offsetof(TFloatVariable, getValueFrom), false, false, 0},
  {NULL}
};

size_t const TFloatVariable_components[] = { offsetof(TFloatVariable, randomGenerator), offsetof(TFloatVariable, sourceVariable), offsetof(TFloatVariable, getValueFrom), 0};
TClassDescription TFloatVariable::st_classDescription = { "TFloatVariable", &typeid(TFloatVariable), &TVariable::st_classDescription, TFloatVariable_properties, TFloatVariable_components };
TClassDescription const *TFloatVariable::classDescription() const { return &TFloatVariable::st_classDescription; }
TOrange *TFloatVariable::clone() const { return mlnew TFloatVariable(*this); }
