 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../libsvm_interface.hpp"
#include <cstddef>



/****** TKernelFunc *****/


TPropertyDescription TKernelFunc_properties[] = {
  {NULL}
};

size_t const TKernelFunc_components[] = { 0};
TClassDescription TKernelFunc::st_classDescription = { "TKernelFunc", &typeid(TKernelFunc), &TOrange::st_classDescription, TKernelFunc_properties, TKernelFunc_components };
TClassDescription const *TKernelFunc::classDescription() const { return &TKernelFunc::st_classDescription; }


/****** TSVMLearner *****/

void *PTSVMLearner_SVMType(void *);
void *PTSVMLearner_Kernel(void *);

TPropertyDescription TSVMLearner_properties[] = {
  {"svm_type", "  SVM type (C_SVC=0, NU_SVC, ONE_CLASS, EPSILON_SVR=3, NU_SVR=4)", &typeid(int), NULL, offsetof(TSVMLearner, svm_type), false, false, PTSVMLearner_SVMType},
  {"kernel_type", "  kernel type (LINEAR=0, POLY, RBF, SIGMOID, CUSTOM=4)", &typeid(int), NULL, offsetof(TSVMLearner, kernel_type), false, false, PTSVMLearner_Kernel},
  {"degree", "polynomial kernel degree", &typeid(float), NULL, offsetof(TSVMLearner, degree), false, false, 0},
  {"gamma", "poly/rbf/sigm parameter", &typeid(float), NULL, offsetof(TSVMLearner, gamma), false, false, 0},
  {"coef0", "poly/sigm parameter", &typeid(float), NULL, offsetof(TSVMLearner, coef0), false, false, 0},
  {"cache_size", "cache size in MB", &typeid(float), NULL, offsetof(TSVMLearner, cache_size), false, false, 0},
  {"eps", "stopping criteria", &typeid(float), NULL, offsetof(TSVMLearner, eps), false, false, 0},
  {"C", "for C_SVC and C_SVR", &typeid(float), NULL, offsetof(TSVMLearner, C), false, false, 0},
  {"nu", "for NU_SVC and ONE_CLASS", &typeid(float), NULL, offsetof(TSVMLearner, nu), false, false, 0},
  {"p", "for C_SVR", &typeid(float), NULL, offsetof(TSVMLearner, p), false, false, 0},
  {"shrinking", "shrinking", &typeid(int), NULL, offsetof(TSVMLearner, shrinking), false, false, 0},
  {"probability", "probability", &typeid(int), NULL, offsetof(TSVMLearner, probability), false, false, 0},
  {"verbose", "verbose", &typeid(bool), NULL, offsetof(TSVMLearner, verbose), false, false, 0},
  {"kernel_func", "custom kernel function", &typeid(POrange), &TKernelFunc::st_classDescription, offsetof(TSVMLearner, kernelFunc), false, false, 0},
  {"needs", "the kind of data that learner needs", &typeid(int), NULL, offsetof(TSVMLearner, needs), true, false, 0},
  {NULL}
};

size_t const TSVMLearner_components[] = { offsetof(TSVMLearner, kernelFunc), 0};
TClassDescription TSVMLearner::st_classDescription = { "TSVMLearner", &typeid(TSVMLearner), &TLearner::st_classDescription, TSVMLearner_properties, TSVMLearner_components };
TClassDescription const *TSVMLearner::classDescription() const { return &TSVMLearner::st_classDescription; }
TOrange *TSVMLearner::clone() const { return mlnew TSVMLearner(*this); }


/****** TSVMLearnerSparse *****/

void *PTSVMLearner_SVMType(void *);
void *PTSVMLearner_Kernel(void *);

TPropertyDescription TSVMLearnerSparse_properties[] = {
  {"use_non_meta", "include non meta attributes in the learning process", &typeid(bool), NULL, offsetof(TSVMLearnerSparse, useNonMeta), false, false, 0},
  {"svm_type", "  SVM type (C_SVC=0, NU_SVC, ONE_CLASS, EPSILON_SVR=3, NU_SVR=4)", &typeid(int), NULL, offsetof(TSVMLearnerSparse, svm_type), false, false, PTSVMLearner_SVMType},
  {"kernel_type", "  kernel type (LINEAR=0, POLY, RBF, SIGMOID, CUSTOM=4)", &typeid(int), NULL, offsetof(TSVMLearnerSparse, kernel_type), false, false, PTSVMLearner_Kernel},
  {"degree", "polynomial kernel degree", &typeid(float), NULL, offsetof(TSVMLearnerSparse, degree), false, false, 0},
  {"gamma", "poly/rbf/sigm parameter", &typeid(float), NULL, offsetof(TSVMLearnerSparse, gamma), false, false, 0},
  {"coef0", "poly/sigm parameter", &typeid(float), NULL, offsetof(TSVMLearnerSparse, coef0), false, false, 0},
  {"cache_size", "cache size in MB", &typeid(float), NULL, offsetof(TSVMLearnerSparse, cache_size), false, false, 0},
  {"eps", "stopping criteria", &typeid(float), NULL, offsetof(TSVMLearnerSparse, eps), false, false, 0},
  {"C", "for C_SVC and C_SVR", &typeid(float), NULL, offsetof(TSVMLearnerSparse, C), false, false, 0},
  {"nu", "for NU_SVC and ONE_CLASS", &typeid(float), NULL, offsetof(TSVMLearnerSparse, nu), false, false, 0},
  {"p", "for C_SVR", &typeid(float), NULL, offsetof(TSVMLearnerSparse, p), false, false, 0},
  {"shrinking", "shrinking", &typeid(int), NULL, offsetof(TSVMLearnerSparse, shrinking), false, false, 0},
  {"probability", "probability", &typeid(int), NULL, offsetof(TSVMLearnerSparse, probability), false, false, 0},
  {"verbose", "verbose", &typeid(bool), NULL, offsetof(TSVMLearnerSparse, verbose), false, false, 0},
  {"kernel_func", "custom kernel function", &typeid(POrange), &TKernelFunc::st_classDescription, offsetof(TSVMLearnerSparse, kernelFunc), false, false, 0},
  {"needs", "the kind of data that learner needs", &typeid(int), NULL, offsetof(TSVMLearnerSparse, needs), true, false, 0},
  {NULL}
};

size_t const TSVMLearnerSparse_components[] = { offsetof(TSVMLearnerSparse, kernelFunc), 0};
TClassDescription TSVMLearnerSparse::st_classDescription = { "TSVMLearnerSparse", &typeid(TSVMLearnerSparse), &TSVMLearner::st_classDescription, TSVMLearnerSparse_properties, TSVMLearnerSparse_components };
TClassDescription const *TSVMLearnerSparse::classDescription() const { return &TSVMLearnerSparse::st_classDescription; }
TOrange *TSVMLearnerSparse::clone() const { return mlnew TSVMLearnerSparse(*this); }


/****** TSVMClassifier *****/

void *PTSVMLearner_SVMType(void *);
void *PTSVMLearner_Kernel(void *);

TPropertyDescription TSVMClassifier_properties[] = {
  {"n_SV", "nSV", &typeid(POrange), &TIntList::st_classDescription, offsetof(TSVMClassifier, nSV), false, false, 0},
  {"rho", "rho", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifier, rho), false, false, 0},
  {"coef", "coef", &typeid(POrange), &TFloatListList::st_classDescription, offsetof(TSVMClassifier, coef), false, false, 0},
  {"prob_a", "probA - pairwise probability information", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifier, probA), false, false, 0},
  {"prob_b", "probB - pairwise probability information", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifier, probB), false, false, 0},
  {"support_vectors", "support vectors", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TSVMClassifier, supportVectors), false, false, 0},
  {"examples", "examples used to train the classifier", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TSVMClassifier, examples), false, false, 0},
  {"kernel_func", "custom kernel function", &typeid(POrange), &TKernelFunc::st_classDescription, offsetof(TSVMClassifier, kernelFunc), false, false, 0},
  {"svm_type", "  SVM type (C_SVC=0, NU_SVC, ONE_CLASS, EPSILON_SVR=3, NU_SVR=4)", &typeid(int), NULL, offsetof(TSVMClassifier, svm_type), false, false, PTSVMLearner_SVMType},
  {"kernel_type", "  kernel type (LINEAR=0, POLY, RBF, SIGMOID, CUSTOM=4)", &typeid(int), NULL, offsetof(TSVMClassifier, kernel_type), false, false, PTSVMLearner_Kernel},
  {"domain", "domain", &typeid(POrange), &TDomain::st_classDescription, offsetof(TSVMClassifier, domain), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TSVMClassifier, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TSVMClassifier, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TSVMClassifier_components[] = { offsetof(TSVMClassifier, nSV), offsetof(TSVMClassifier, rho), offsetof(TSVMClassifier, coef), offsetof(TSVMClassifier, probA), offsetof(TSVMClassifier, probB), offsetof(TSVMClassifier, supportVectors), offsetof(TSVMClassifier, examples), offsetof(TSVMClassifier, kernelFunc), offsetof(TSVMClassifier, domain), offsetof(TSVMClassifier, classVar), 0};
TClassDescription TSVMClassifier::st_classDescription = { "TSVMClassifier", &typeid(TSVMClassifier), &TClassifierFD::st_classDescription, TSVMClassifier_properties, TSVMClassifier_components };
TClassDescription const *TSVMClassifier::classDescription() const { return &TSVMClassifier::st_classDescription; }
TOrange *TSVMClassifier::clone() const { return mlnew TSVMClassifier(*this); }


/****** TSVMClassifierSparse *****/

void *PTSVMLearner_SVMType(void *);
void *PTSVMLearner_Kernel(void *);

TPropertyDescription TSVMClassifierSparse_properties[] = {
  {"use_non_meta", "include non meta attributes", &typeid(bool), NULL, offsetof(TSVMClassifierSparse, useNonMeta), false, false, 0},
  {"n_SV", "nSV", &typeid(POrange), &TIntList::st_classDescription, offsetof(TSVMClassifierSparse, nSV), false, false, 0},
  {"rho", "rho", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifierSparse, rho), false, false, 0},
  {"coef", "coef", &typeid(POrange), &TFloatListList::st_classDescription, offsetof(TSVMClassifierSparse, coef), false, false, 0},
  {"prob_a", "probA - pairwise probability information", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifierSparse, probA), false, false, 0},
  {"prob_b", "probB - pairwise probability information", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TSVMClassifierSparse, probB), false, false, 0},
  {"support_vectors", "support vectors", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TSVMClassifierSparse, supportVectors), false, false, 0},
  {"examples", "examples used to train the classifier", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TSVMClassifierSparse, examples), false, false, 0},
  {"kernel_func", "custom kernel function", &typeid(POrange), &TKernelFunc::st_classDescription, offsetof(TSVMClassifierSparse, kernelFunc), false, false, 0},
  {"svm_type", "  SVM type (C_SVC=0, NU_SVC, ONE_CLASS, EPSILON_SVR=3, NU_SVR=4)", &typeid(int), NULL, offsetof(TSVMClassifierSparse, svm_type), false, false, PTSVMLearner_SVMType},
  {"kernel_type", "  kernel type (LINEAR=0, POLY, RBF, SIGMOID, CUSTOM=4)", &typeid(int), NULL, offsetof(TSVMClassifierSparse, kernel_type), false, false, PTSVMLearner_Kernel},
  {"domain", "domain", &typeid(POrange), &TDomain::st_classDescription, offsetof(TSVMClassifierSparse, domain), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TSVMClassifierSparse, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TSVMClassifierSparse, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TSVMClassifierSparse_components[] = { offsetof(TSVMClassifierSparse, nSV), offsetof(TSVMClassifierSparse, rho), offsetof(TSVMClassifierSparse, coef), offsetof(TSVMClassifierSparse, probA), offsetof(TSVMClassifierSparse, probB), offsetof(TSVMClassifierSparse, supportVectors), offsetof(TSVMClassifierSparse, examples), offsetof(TSVMClassifierSparse, kernelFunc), offsetof(TSVMClassifierSparse, domain), offsetof(TSVMClassifierSparse, classVar), 0};
TClassDescription TSVMClassifierSparse::st_classDescription = { "TSVMClassifierSparse", &typeid(TSVMClassifierSparse), &TSVMClassifier::st_classDescription, TSVMClassifierSparse_properties, TSVMClassifierSparse_components };
TClassDescription const *TSVMClassifierSparse::classDescription() const { return &TSVMClassifierSparse::st_classDescription; }
TOrange *TSVMClassifierSparse::clone() const { return mlnew TSVMClassifierSparse(*this); }
