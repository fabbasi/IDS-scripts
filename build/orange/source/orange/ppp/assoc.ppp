 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../assoc.hpp"
#include <cstddef>



/****** TAssociationRule *****/


TPropertyDescription TAssociationRule_properties[] = {
  {"left", "left side of the rule", &typeid(TExample), NULL, offsetof(TAssociationRule, left), true, false, 0},
  {"right", "right side of the rule", &typeid(TExample), NULL, offsetof(TAssociationRule, right), true, false, 0},
  {"support", "support for the rule", &typeid(float), NULL, offsetof(TAssociationRule, support), false, false, 0},
  {"confidence", "confidence of the rule", &typeid(float), NULL, offsetof(TAssociationRule, confidence), false, false, 0},
  {"coverage", "rule's coverage", &typeid(float), NULL, offsetof(TAssociationRule, coverage), false, false, 0},
  {"strength", "rule's strength", &typeid(float), NULL, offsetof(TAssociationRule, strength), false, false, 0},
  {"lift", "rule's lift", &typeid(float), NULL, offsetof(TAssociationRule, lift), false, false, 0},
  {"leverage", "rule's leverage", &typeid(float), NULL, offsetof(TAssociationRule, leverage), false, false, 0},
  {"n_applies_left", "number of examples covered by the rule's left side", &typeid(float), NULL, offsetof(TAssociationRule, nAppliesLeft), false, false, 0},
  {"n_applies_right", "number of examples covered by the rule's right side", &typeid(float), NULL, offsetof(TAssociationRule, nAppliesRight), false, false, 0},
  {"n_applies_both", "number of examples covered by the rule", &typeid(float), NULL, offsetof(TAssociationRule, nAppliesBoth), false, false, 0},
  {"n_examples", "number of learning examples", &typeid(float), NULL, offsetof(TAssociationRule, nExamples), false, false, 0},
  {"n_left", "number of items on the rule's left side", &typeid(int), NULL, offsetof(TAssociationRule, nLeft), true, false, 0},
  {"n_right", "number of items on the rule's right side", &typeid(int), NULL, offsetof(TAssociationRule, nRight), true, false, 0},
  {"examples", "examples which the rule was built from", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TAssociationRule, examples), true, false, 0},
  {"match_left", "indices of examples that match the left side of the rule", &typeid(POrange), &TIntList::st_classDescription, offsetof(TAssociationRule, matchLeft), true, false, 0},
  {"match_both", "indices to examples that match both sides of the rule", &typeid(POrange), &TIntList::st_classDescription, offsetof(TAssociationRule, matchBoth), true, false, 0},
  {NULL}
};

size_t const TAssociationRule_components[] = { offsetof(TAssociationRule, left), offsetof(TAssociationRule, right), offsetof(TAssociationRule, examples), offsetof(TAssociationRule, matchLeft), offsetof(TAssociationRule, matchBoth), 0};
TClassDescription TAssociationRule::st_classDescription = { "TAssociationRule", &typeid(TAssociationRule), &TOrange::st_classDescription, TAssociationRule_properties, TAssociationRule_components };
TClassDescription const *TAssociationRule::classDescription() const { return &TAssociationRule::st_classDescription; }
TOrange *TAssociationRule::clone() const { return mlnew TAssociationRule(*this); }


/****** TAssociationRulesInducer *****/


TPropertyDescription TAssociationRulesInducer_properties[] = {
  {"max_item_sets", "maximal number of itemsets (increase if you want)", &typeid(int), NULL, offsetof(TAssociationRulesInducer, maxItemSets), false, false, 0},
  {"confidence", "required confidence", &typeid(float), NULL, offsetof(TAssociationRulesInducer, confidence), false, false, 0},
  {"support", "required support", &typeid(float), NULL, offsetof(TAssociationRulesInducer, support), false, false, 0},
  {"classification_rules", "if true, rules will have the class and only the class attribute on the right-hand side", &typeid(bool), NULL, offsetof(TAssociationRulesInducer, classificationRules), false, false, 0},
  {"store_examples", "if true, each rule is going to have tables with references to examples which match its left side or both sides", &typeid(bool), NULL, offsetof(TAssociationRulesInducer, storeExamples), false, false, 0},
  {NULL}
};

size_t const TAssociationRulesInducer_components[] = { 0};
TClassDescription TAssociationRulesInducer::st_classDescription = { "TAssociationRulesInducer", &typeid(TAssociationRulesInducer), &TOrange::st_classDescription, TAssociationRulesInducer_properties, TAssociationRulesInducer_components };
TClassDescription const *TAssociationRulesInducer::classDescription() const { return &TAssociationRulesInducer::st_classDescription; }
TOrange *TAssociationRulesInducer::clone() const { return mlnew TAssociationRulesInducer(*this); }


/****** TAssociationRulesSparseInducer *****/


TPropertyDescription TAssociationRulesSparseInducer_properties[] = {
  {"max_item_sets", "maximal number of itemsets (increase if you want)", &typeid(int), NULL, offsetof(TAssociationRulesSparseInducer, maxItemSets), false, false, 0},
  {"confidence", "required confidence", &typeid(float), NULL, offsetof(TAssociationRulesSparseInducer, confidence), false, false, 0},
  {"support", "required support", &typeid(float), NULL, offsetof(TAssociationRulesSparseInducer, support), false, false, 0},
  {"store_examples", "stores examples corresponding to rules", &typeid(bool), NULL, offsetof(TAssociationRulesSparseInducer, storeExamples), false, false, 0},
  {NULL}
};

size_t const TAssociationRulesSparseInducer_components[] = { 0};
TClassDescription TAssociationRulesSparseInducer::st_classDescription = { "TAssociationRulesSparseInducer", &typeid(TAssociationRulesSparseInducer), &TOrange::st_classDescription, TAssociationRulesSparseInducer_properties, TAssociationRulesSparseInducer_components };
TClassDescription const *TAssociationRulesSparseInducer::classDescription() const { return &TAssociationRulesSparseInducer::st_classDescription; }
TOrange *TAssociationRulesSparseInducer::clone() const { return mlnew TAssociationRulesSparseInducer(*this); }


/****** TItemsetsSparseInducer *****/


TPropertyDescription TItemsetsSparseInducer_properties[] = {
  {"max_item_sets", "maximal number of itemsets (increase if you want)", &typeid(int), NULL, offsetof(TItemsetsSparseInducer, maxItemSets), false, false, 0},
  {"support", "required support", &typeid(float), NULL, offsetof(TItemsetsSparseInducer, support), false, false, 0},
  {"store_examples", "stores examples corresponding to itemsets", &typeid(bool), NULL, offsetof(TItemsetsSparseInducer, storeExamples), false, false, 0},
  {NULL}
};

size_t const TItemsetsSparseInducer_components[] = { 0};
TClassDescription TItemsetsSparseInducer::st_classDescription = { "TItemsetsSparseInducer", &typeid(TItemsetsSparseInducer), &TOrange::st_classDescription, TItemsetsSparseInducer_properties, TItemsetsSparseInducer_components };
TClassDescription const *TItemsetsSparseInducer::classDescription() const { return &TItemsetsSparseInducer::st_classDescription; }
TOrange *TItemsetsSparseInducer::clone() const { return mlnew TItemsetsSparseInducer(*this); }


/****** TAssociationLearner *****/


TPropertyDescription TAssociationLearner_properties[] = {
  {"confidence", "required confidence", &typeid(float), NULL, offsetof(TAssociationLearner, confidence), false, false, 0},
  {"support", "required support", &typeid(float), NULL, offsetof(TAssociationLearner, support), false, false, 0},
  {"vote_weight", "vote weight (s=support, c=confidence, p=product)", &typeid(int), NULL, offsetof(TAssociationLearner, voteWeight), false, false, 0},
  {"max_item_sets", "maximal number of itemsets (increase if you want)", &typeid(int), NULL, offsetof(TAssociationLearner, maxItemSets), false, false, 0},
  {"needs", "the kind of data that learner needs", &typeid(int), NULL, offsetof(TAssociationLearner, needs), true, false, 0},
  {NULL}
};

size_t const TAssociationLearner_components[] = { 0};
TClassDescription TAssociationLearner::st_classDescription = { "TAssociationLearner", &typeid(TAssociationLearner), &TLearner::st_classDescription, TAssociationLearner_properties, TAssociationLearner_components };
TClassDescription const *TAssociationLearner::classDescription() const { return &TAssociationLearner::st_classDescription; }
TOrange *TAssociationLearner::clone() const { return mlnew TAssociationLearner(*this); }


/****** TAssociationClassifier *****/


TPropertyDescription TAssociationClassifier_properties[] = {
  {"rules", "association rules", &typeid(POrange), &TAssociationRules::st_classDescription, offsetof(TAssociationClassifier, rules), false, false, 0},
  {"vote_weight", "vote weight (s=support, c=confidence, p=product)", &typeid(int), NULL, offsetof(TAssociationClassifier, voteWeight), false, false, 0},
  {"domain", "domain", &typeid(POrange), &TDomain::st_classDescription, offsetof(TAssociationClassifier, domain), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TAssociationClassifier, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TAssociationClassifier, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TAssociationClassifier_components[] = { offsetof(TAssociationClassifier, rules), offsetof(TAssociationClassifier, domain), offsetof(TAssociationClassifier, classVar), 0};
TClassDescription TAssociationClassifier::st_classDescription = { "TAssociationClassifier", &typeid(TAssociationClassifier), &TClassifierFD::st_classDescription, TAssociationClassifier_properties, TAssociationClassifier_components };
TClassDescription const *TAssociationClassifier::classDescription() const { return &TAssociationClassifier::st_classDescription; }
TOrange *TAssociationClassifier::clone() const { return mlnew TAssociationClassifier(*this); }
