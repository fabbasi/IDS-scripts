/* This file was generated by pyxtract 
   Do not edit.*/

#include "externs.px"

PyObject *dist(PyObject *, PyObject *args);
PyObject *optimizeAnchors(PyObject *, PyObject *args, PyObject *keywords);
PyObject *optimizeAnchorsR(PyObject *, PyObject *args, PyObject *keywords);
PyObject *optimizeAnchorsRadial(PyObject *, PyObject *args, PyObject *keywords);
PyObject *potentialsBitmap(PyObject *, PyObject *args, PyObject *);
PyObject *qhull(PyObject *, PyObject *arg);
PyObject *qing(PyObject *, PyObject *args);
PyObject *star(PyObject *, PyObject *args);


PyMethodDef orangeomFunctions[]={
     {"dist", (binaryfunc)dist, METH_VARARGS, "(p, t)"},
     {"optimizeAnchors", (binaryfunc)optimizeAnchors, METH_VARARGS | METH_KEYWORDS, "(scaledData, classes, anchors[, attractG=1.0, repelG=-1.0, law=InverseLinear, steps=1, normalizeExamples=1]) -> new-anchors"},
     {"optimizeAnchorsR", (binaryfunc)optimizeAnchorsR, METH_VARARGS | METH_KEYWORDS, "(scaledData, classes, anchors[, attractG=1.0, repelG=-1.0, law=InverseLinear, steps=1, normalizeExamples=1]) -> new-anchors"},
     {"optimizeAnchorsRadial", (binaryfunc)optimizeAnchorsRadial, METH_VARARGS | METH_KEYWORDS, "(scaledData, classes, anchors[, attractG=1.0, repelG=-1.0, law=InverseLinear, steps=1, normalizeExamples=1]) -> new-anchors"},
     {"potentialsBitmap", (binaryfunc)potentialsBitmap, METH_VARARGS, "(P2NN, rx, ry, offx, offy, cellsize, scaleFactor, grid) -> bitmap as string"},
     {"qhull", (binaryfunc)qhull, METH_O, "(array) -> ?"},
     {"qing", (binaryfunc)qing, METH_VARARGS, "(points, func_values, simplices) -> (pairs, critical, corrected)"},
     {"star", (binaryfunc)star, METH_VARARGS, "(t, tri)"},
     {NULL, NULL}
};

int noOforangeomClasses=11;

TOrangeType *orangeomClasses[]={
    &PyOrGraphLayout_Type,
    &PyOrKruskalStress_Type,
    &PyOrMDS_Type,
    &PyOrNetwork_Type,
    &PyOrNetworkOptimization_Type,
    &PyOrPathfinder_Type,
    &PyOrSammonStress_Type,
    &PyOrSgnRelStress_Type,
    &PyOrSgnSammonStress_Type,
    &PyOrStressFunc_Type,
    &PyOrStressFunc_Python_Type,
    NULL};



void addorangeomConstants(PyObject *mod) {
     PyModule_AddObject(mod, "version", orangeVersion);


     PyModule_AddObject(mod, "GraphLayout", (PyObject *)&PyOrGraphLayout_Type);
     PyModule_AddObject(mod, "KruskalStress", (PyObject *)&PyOrKruskalStress_Type);
     PyModule_AddObject(mod, "MDS", (PyObject *)&PyOrMDS_Type);
     PyModule_AddObject(mod, "Network", (PyObject *)&PyOrNetwork_Type);
     PyModule_AddObject(mod, "NetworkOptimization", (PyObject *)&PyOrNetworkOptimization_Type);
     PyModule_AddObject(mod, "Pathfinder", (PyObject *)&PyOrPathfinder_Type);
     PyModule_AddObject(mod, "SammonStress", (PyObject *)&PyOrSammonStress_Type);
     PyModule_AddObject(mod, "SgnRelStress", (PyObject *)&PyOrSgnRelStress_Type);
     PyModule_AddObject(mod, "SgnSammonStress", (PyObject *)&PyOrSgnSammonStress_Type);
     PyModule_AddObject(mod, "StressFunc", (PyObject *)&PyOrStressFunc_Type);
     PyModule_AddObject(mod, "StressFunc_Python", (PyObject *)&PyOrStressFunc_Python_Type);
}


#ifdef _MSC_VER
  #define WIN32_LEAN_AND_MEAN
  #include <windows.h>
  BOOL APIENTRY DllMain( HANDLE, DWORD  ul_reason_for_call, LPVOID)  { return TRUE; }
#endif

extern ORANGEOM_API PyObject *orangeomModule;

ORANGE_API void addClassList(TOrangeType **);

extern "C" ORANGEOM_API void initorangeom()
{ 
  if (!initorangeomExceptions())
    return;

  for(TOrangeType **type=orangeomClasses; *type; type++)
    if (PyType_Ready((PyTypeObject *)*type)<0)
      return;
  addClassList(orangeomClasses);

  gcorangeomUnsafeStaticInitialization();
  orangeomModule = Py_InitModule("orangeom", orangeomFunctions);  
  addorangeomConstants(orangeomModule);
}
